
# Порівняння алгоритмів сортування

## Time Complexity (TC) of Algorithms

| Algorithm       | Best Case     | Average Case  | Worst Case    |
| --------------- | ------------- | ------------- | ------------- |
| Merge Sort      | O(n log n)    | O(n log n)    | O(n log n)    |
| Insertion Sort  | O(n)          | O(n^2)        | O(n^2)        |
| Timsort         | O(n)          | O(n log n)    | O(n log n)    |


## Порівняння алгоритмів сортування (random дані)

    Розмір |  Insertion Sort |      Merge Sort |         Timsort
       100 |        0.000160 |        0.000160 |        0.000012
       500 |        0.005083 |        0.000897 |        0.000054
      1000 |        0.022261 |        0.002000 |        0.000112
      5000 |        0.553072 |        0.010236 |        0.000563
     10000 |        2.150914 |        0.022193 |        0.001226

## Порівняння алгоритмів сортування (sorted дані):

    Розмір |  Insertion Sort |      Merge Sort |         Timsort
       100 |        0.000009 |        0.000094 |        0.000003
       500 |        0.000046 |        0.000524 |        0.000006
      1000 |        0.000100 |        0.001181 |        0.000010
      5000 |        0.000561 |        0.006839 |        0.000056
     10000 |        0.001116 |        0.014322 |        0.000086

## Порівняння алгоритмів сортування (reverse дані):

    Розмір |  Insertion Sort |      Merge Sort |         Timsort
       100 |        0.000267 |        0.000100 |        0.000003
       500 |        0.007862 |        0.000538 |        0.000007
      1000 |        0.035974 |        0.001168 |        0.000012
      5000 |        1.048135 |        0.007731 |        0.000072
     10000 |        4.400040 |        0.014641 |        0.000095


### Висновки:

1. Ефективність **TimSort**:
    - Timsort послідовно показує найкращу продуктивність у всіх сценаріях, незалежно від розміру масиву чи типу даних.
    - Його перевага особливо помітна на великих масивах (5000 і 10000 елементів).

2. Продуктивність **Insertion Sort**:
   - Добре працює на малих масивах і відсортованих даних.
   - Значно погіршується на великих масивах, особливо для випадкових і зворотно відсортованих даних.
   - Найгірші результати показує на зворотно відсортованих даних великого розміру.

3. Стабільність **Merge Sort**: 
   - Демонструє стабільну продуктивність незалежно від типу даних.
   - Ефективніший за Insertion Sort на великих масивах, але поступається Timsort.

4. Вплив розміру масиву:
   - На малих масивах (100-500 елементів) різниця між алгоритмами менш помітна.
   - На великих масивах (5000-10000 елементів) різниця стає дуже значною.
5. Вплив типу даних:
   - Всі алгоритми працюють найкраще на вже відсортованих даних.
   - Зворотно відсортовані дані є найскладнішими для Insertion Sort.
   - Timsort адаптується найкраще до різних типів даних.

Ці результати підтверджують теоретичну складність алгоритмів і демонструють, чому Timsort є стандартним алгоритмом сортування в Python. Він поєднує кращі аспекти Insertion Sort і Merge Sort, забезпечуючи високу ефективність у різноманітних сценаріях.



