
# Порівняння алгоритмів сортування

## Time Complexity (TC) of Algorithms

| Algorithm       | Best Case     | Average Case  | Worst Case    |
| --------------- | ------------- | ------------- | ------------- |
| Merge Sort      | O(n log n)    | O(n log n)    | O(n log n)    |
| Insertion Sort  | O(n)          | O(n^2)        | O(n^2)        |
| Timsort         | O(n)          | O(n log n)    | O(n log n)    |


## Порівняння алгоритмів сортування (random дані)

    Розмір |  Insertion Sort |      Merge Sort |         Timsort
--------------------------------------------------------------
       100 |        0.000160 |        0.000160 |        0.000012
       500 |        0.005083 |        0.000897 |        0.000054
      1000 |        0.022261 |        0.002000 |        0.000112
      5000 |        0.553072 |        0.010236 |        0.000563
     10000 |        2.150914 |        0.022193 |        0.001226

## Порівняння алгоритмів сортування (sorted дані):

    Розмір |  Insertion Sort |      Merge Sort |         Timsort
--------------------------------------------------------------
       100 |        0.000009 |        0.000094 |        0.000003
       500 |        0.000046 |        0.000524 |        0.000006
      1000 |        0.000100 |        0.001181 |        0.000010
      5000 |        0.000561 |        0.006839 |        0.000056
     10000 |        0.001116 |        0.014322 |        0.000086

## Порівняння алгоритмів сортування (reverse дані):

--------------------------------------------------------------
       100 |        0.000267 |        0.000100 |        0.000003
       500 |        0.007862 |        0.000538 |        0.000007
      1000 |        0.035974 |        0.001168 |        0.000012
      5000 |        1.048135 |        0.007731 |        0.000072
     10000 |        4.400040 |        0.014641 |        0.000095

## Візуалізація даних
Посилання: https://colab.research.google.com/drive/14aR5Mjn7zihhTs1UYsG6-GBCrTxawiuq?usp=sharing


### Висновки:

1. **TimSort** показує найкращу продуктивність у всіх сценаріях, що підтверджує його ефективність як вбудованого методу сортування в Python.

2. **Merge Sort** демонструє стабільну продуктивність незалежно від початкового стану даних, але поступається TimSort.

3. **Insertion Sort** ефективний на малих наборах даних та майже відсортованих масивах, але його продуктивність значно погіршується на великих невідсортованих масивах.

4. TimSort поєднує переваги Insertion Sort та Merge Sort, що робить його адаптивним до різних типів вхідних даних.

5. Для більшості практичних застосувань рекомендується використовувати вбудовані методи сортування Python (які базуються на TimSort), оскільки вони забезпечують оптимальну продуктивність у різноманітних сценаріях.

Це дослідження підтверджує теоретичні оцінки складності алгоритмів та демонструє важливість вибору правильного алгоритму сортування залежно від характеристик вхідних даних та вимог до продуктивності.


